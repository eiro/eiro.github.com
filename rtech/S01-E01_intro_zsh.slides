  vim: ft=slides et ts=2 sts=2 sw=2

â€º introduction

  vous aussi ...

â€º prÃ©requis

  apt install tilix zsh # installer le confort
  getent passwd $UID    # verifier votre shell par dÃ©faut
  ps hocmd $$           # vÃ©rifier si vous Ãªtes bien sous zsh
  exec zsh              # passer sous zsh
  chsh -s $(which zsh)  # changer de shell

â€º configuration

   ~/.zshenv # pour tous les zsh â†’ helpers, options
   ~/.zshrc  # pour les zsh interactifs
             # â†’ paramÃ¨trage de la zle, ...

  # oh-my-zsh: le hummer

â€º zsh-newuser-install

  0) Exit, creating the file ~/.zshrc containing
     just a comment.
     That will prevent this function being run again.

  2) Populate your ~/.zshrc with the configuration
     recommended

  pour recommencer: rm ~/.zshrc

â€º zsh

  unix shell inspirÃ© de rc, tcsh, mksh,...

  http://www.bash2zsh.com/zsh_refcard/refcard.pdf


â€º unix shell

  shell = interface homme machine (IHM)
    â–¶ GUI   = graphical user interface
    â–¶ NUI   = natural user interface
    â–¶ CLI   = command line interface
      REPL  = read,eval,print loop

      read/write sont des appels systÃ¨me bloquants
      (man 2 read, man 2 write)

â€º unix shell

  faire des trucs â”‚ rapidement
                  â”‚ Ã  distance
                  â”‚ quand la GUI fait sa GUI
                  â”‚ compliquÃ©s
                  â”‚ pour Ã©tendre les trucs

â€º demos ?

  mkdir -p media/{1976..2018}/{images,videos,textes,misc}

  media â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         1976         ....           2018
         â”œâ”€ images    â”œâ”€ images      â”œâ”€ images
         â”œâ”€ videos    â”œâ”€ videos      â”œâ”€ videos
         â”œâ”€ textes    â”œâ”€ textes      â”œâ”€ textes
         â””â”€ misc      â””â”€ misc        â””â”€ misc

â€º demos ?

  msg () mutt -H- -s "$@[2,-1]" $1
  cpt () msg cpt "$@"

â€º your langage before it was cool

  î€‹ async, promises, channels, ...
  î€‹ immutable
  î€‹ higher order
  î€‹ composition

    shell   â–¶  nat | filter is-prime | take 5 | sum
    haskell â–¶  take 5 $ filter is-prime nat
    perl6   â–¶  say [+] (0..âˆž).grep(*.is-prime)[^5]
    JS.next â–¶  nat()  |> is-prime |> take ???

â€º pour Ãªtre honnÃªte ...

  il y a *enfin* de la compÃ©tition

  î€‹ perl6   : whipuptitude++
  î€‹ haskell : securitÃ©++
  î€‹ crystal : performances++

â€º zsh vs dash, rc, tcsh, mksh, bash ...

  î€‹ lancer une commande: dash
  î€‹ environements restreints: rc, mksh
  î€‹ tout confort: zsh

  { for it ( ={mksh,dash,bash,zsh,zsh-static,9/rc}(:A) )
    ls -s $it
  } | sort -n

  120 /bin/dash
  136 /usr/lib/plan9/bin/rc
  272 /bin/mksh
  840 /bin/zsh
  1092 /bin/bash
  2528 /bin/zsh-static # avec toutes les extensions

â€º bash (Ã  mes yeux)

  î€‹ trop gros pour concurrencer mksh
  î€‹ pas assez riche pour concurrencer zsh
  î€‹ syntaxes parfois malheureuse
  î€‹ argument courant: le shell par defaut
    î€‹ c'est faux
    î€‹ c'est insuffisant

  bash est peut-Ãªtre devenu bien ...
  j'attend toujours la demo!  (20 ans)

â€º POSIX

  î€‹ portabilitÃ© hasardeuse
  î€‹ fonctionalitÃ©s limitÃ©es

  â‡’ implementations vs standards

  zsh + ( 9base | GNU coreutils | sbase | ...)

â€º exemple (POSIX style)

  which vim                 # â‡’ /usr/bin/vim
  realpath /usr/bin/vim     # â‡’ /usr/bin/vim.gtk3
  dirname /usr/bin/vim.gtk3 # â‡’ /usr/bin
  cd /usr/bin

  cd $( dirname $( realpath $( which vim )))

â€º donc

  cd $( dirname $( realpath $( which vim )))

  î€‹ 3 forks
  î€‹ 2 dependences (GNU coreutils)
  î€‹ 1 lecture pas simple

â€º expansions

  reconstruire la *liste* des paramÃ¨tres avant execution

â€º exemples

  Brace Expansion:

  touch {udp,tcp}_echo{,.{c,h}}
  â‡’ touch udp_echo udp_echo.c udp_echo.h \
        tcp_echo tcp_echo.c tcp_echo.h

  Filename Expansion:

  print -l *.h
  â‡’ udp_echo.h tcp_echo.h

â€º man zshexpn

          ! â”‚ History Expansion
            â”‚ Alias Expansion
            â”‚ Process Substitution
          $ â”‚ Parameter Expansion
    $() =() â”‚ Command Substitution
   []  (()) â”‚ Arithmetic Expansion
         {} â”‚ Brace Expansion
  * ? = *() â”‚ Filename Expansion
        *:x â”‚ Filename Generation

â€º filename expansions

  classiques

  glob   â”‚ regexp â”‚
         â”‚        â”‚
  [a-z]  â”‚ [a-z]  â”‚ un mÃ©tacaractÃ¨re
  ?      â”‚ .      â”‚ un symbole
  *      â”‚ .*     â”‚ de 0 Ã  n symbole

  mais aussi quantifiers, atoms, motifs d'exclusions,
  fonctions de filtrage, case sensitivitÃ©, captures,
  ...

â€º filename expansions

  les motifs :
  î€‹ permettent de tester des chaines
  î€‹ peuvent Ãªtre nommÃ©s

  [[ aba == ab* ]] && echo ok

  starts_with_ab='ab*'
  [[ aba == $~starts_with_ab ]] && echo ok

â€º modifiers de filename expansion

    () Ã  la fin d'une chaine

    print *.txt
    â‡’ zsh: no matches found: *.txt
    print *.txt(N)
    â‡’

    print /etc/passwd(N)
    â‡’ liste vide si /etc/passwd n'existe pas

â€º exemples de filename expansion

    touch {local,distant,new,old}.{txt,jpeg}

    print *.txt
    â‡’ distant.txt local.txt new.txt old.txt

    print *.txt(:r)
    â‡’ distant local new old

â€º exemples de filename expansion

    print *.txt
    â‡’ distant.txt local.txt new.txt old.txt

    print *.txt(:h)
    â‡’ . . . .

    print *.txt(:A:h)
    â‡’ /tmp /tmp /tmp /tmp

â€º POSIX vs zsh

  cd $( dirname $( realpath $( which vim )))

  which vim                 # =vim
  realpath /usr/bin/vim     # /usr/bin/vim(:A)
  dirname /usr/bin/vim.gtk3 # /usr/bin/vim(:h)

  cd =vim(:A:h)

â€º filename generation

  a=/tmp/test/foo.txt  â”‚
  print :r = $a:r      â”‚ r = /tmp/test/foo
  print :e = $a:e      â”‚ e = txt
  print :t = $a:t      â”‚ t = foo.txt
  print :h = $a:h      â”‚ h = /tmp/test

â€º diffÃ©rence

  $a:h    # substitution sur une chaine
  $a(:h)  # recherche de fichier

    â‡’ erreur si le path n'existe pas
    â‡’ ajouter (N) pour renvoyer une liste vide

â€º diffÃ©rence

  a=/etc/passwd b=/foo/passwd
  print chemin $a(N:h) $b(N:h)
  â‡’ chemin /etc

  setopt extendedglob ~/.zshenv

  print subst  $a:h $b:h
  â‡’ subst /etc /foo

â€º unix culture  ...

  :A :h :r : :t ... dispo dans d'autres outils.

  exemple:
  vi src/renater/unix/tools/current/tcp_echo.c

    :cd %:h     # cd src/renater/unix/tools/current
    :make %:r   # make tcp_echo

â€º syntaxe

  î€‹ barewords
  î€‹ fonctions variadiques
  î€‹ interpolation â‡’ parameter expansion
  î€‹ Ã©chappement avec \, '' et ""

â€º hello world

  print hello   world # ici votre publicitÃ©
    â†’ "$*" =  join(" ", @_)
    â‡’ hello world

  print hello \ world # plus rien
    â‡’ hello  world
    # le 2Ã¨me paramÃ¨tre vaut ' world'

  print hello \ world \# plus rien
    â‡’ hello  world # plus rien

â€º quotes

  print the \ \ \ $USER
  â‡’ the   mc

  print the "   $USER"
  â‡’ the   mc

  print the \ \ \$USER
  â‡’ the   $USER

  print the '  $USER'
  â‡’ the   $USER

â€º moar quotes

  print "L'Insoutenable LÃ©gÃ¨retÃ© de $USER"
  â‡’ L'Insoutenable LÃ©gÃ¨retÃ© de mc



  print 'L'Insoutenable LÃ©gÃ¨retÃ© de $USER'
  â‡’ zsh: unmatched '

â€º moar quotes

  print "L'Insoutenable LÃ©gÃ¨retÃ© de $USER"
  â‡’ L'Insoutenable LÃ©gÃ¨retÃ© de mc


  print 'L'Insoutenable LÃ©gÃ¨retÃ© de $USER'
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                  ^
                           unmatched quote
        $1 = LInsoutenable

â€º moar quotes

  print 'LÂ´Insoutenable LÃ©gÃ¨retÃ© de $USER'
  â‡’ LÂ´Insoutenable LÃ©gÃ¨retÃ© de $USER
  # compose + ''

  print L\''Insoutenable LÃ©gÃ¨retÃ© de $USER'
  print L\'Insoutenable 'LÃ©gÃ¨retÃ© de $USER'
  â‡’ L'Insoutenable LÃ©gÃ¨retÃ© de $USER

  setopt rcquotes
  print 'L''Insoutenable LÃ©gÃ¨retÃ© de $USER'
  â‡’ L'Insoutenable LÃ©gÃ¨retÃ© de $USER

â€º affectation

  to=franÃ§is
  print "To: $to"

  â‡’ To: franÃ§is

â€º plus y'a d'espace et moins je respire

    to=franÃ§is  â”‚    syntaxiquement correct
   to= franÃ§is  â”‚ ðŸ”¥ "
  to = franÃ§is  â”‚ ðŸ”¥ "
   to =franÃ§is  â”‚ ðŸ”¥ "

â€º fonction

  garos () print "rend la raquette Ã  $to"

  garos ()
    print "rend la raquette Ã  $to"

  garos () { print "rend la raquette Ã  $to" }

  # POSIX compliant

  garos () { print "rend la raquette Ã  $to"; }
  garos () {
    print "rend la raquette Ã  $to"
  }

â€º affectation, fonction, expansion, attention

  garos () print "rend la raquette Ã  $to"
  to=yannick
  garos

  â‡’ rend la raquette Ã  yannick

â€º affectation, fonction, expansion, attention

  garos () print "rend la raquette Ã  $to"
  to=yannick
  to=roland garos
  garos

  â”‚ rend la raquette Ã  roland
  â”‚ rend la raquette Ã  yannick

â€º affectation, fonction, expansion, attention

  to=yannick
  garos () print "rend la raquette Ã  $to"
  to='roland garos'
  garos

  â‡’ rend la raquette Ã  roland garos

â€º affectation, fonction, expansion, attention

  to () print mais alors pas du to: "\n* "$^@
  to = day
  to =vim

  â”‚ mais alors pas du to: 
  â”‚ * = 
  â”‚ * day
  â”‚ mais alors pas du to: 
  â”‚ * /usr/bin/vim

â€º rÃ©sumÃ©

    to=franÃ§is  â”‚  affectation de to
   to= franÃ§is  â”‚  appelle franÃ§is en localisant to
  to = franÃ§is  â”‚  appelle to avec '=' 'franÃ§is'
   to =franÃ§is  â”‚  appelle to avec le path de franÃ§is

â€º la rigueur

  to=play
  print toma$to   # â‡’ tomaplay
  print $tomate   # â‡’

â€º la rigueur

  set -u          #1 setopt nounset
  to=play         #2 affectation
  print toma$to   #3 â‡’ tomaplay
  print $tomate   #4 â‡’ zsh: tomate: parameter not set

  set +u          #5 setopt unset
  print toma$to   #6 â‡’ toma
  print $tomate   #7 â‡’

â€º Ã©chapper

  to=play
  print ${to}mate  # â‡’ playmate
  print $to\mate   # â‡’ playmate
  print $to\nate   # â‡’ playnate
  print "$to\nate" # â‡’ play
                   # â‡’ ate

â€º flags

  print hello world
  # â‡’ hello world

  print -O hello world
  # â‡’ world hello

  print -l hello world
  # â‡’ hello
  # â‡’ world

â€º flags composition

  print -lO hello world
  # â‡’ world
  # â‡’ hello

â€º flags annulation

  print -- -lO hello world
  # â‡’ -lO hello world

â€º tron legacy

  mcp () print greetings, program
  mcp from the computer

  â‡’ greetings, program

â€º paramÃ¨tres nommÃ©s

  print hello ' world'

  la commande           â”‚ 0 â”‚ print
  le paramÃ¨tre 1        â”‚ 1 â”‚ hello
  le paramÃ¨tre 2        â”‚ 2 â”‚ ' world'
  le dernier paramÃ¨tre  â”‚ _ â”‚ ' world'
  paramÃ¨tres concatÃ©nÃ©s â”‚ * â”‚ 'hello  world'
  nombre de paramÃ¨tres  â”‚ # â”‚ 2
  tous les paramÃ¨tres   â”‚ @ â”‚ ( hello ' world' )

â€º tron legacy

  mcp () print greetings, $1
  mcp

  â‡’ mcp:3: 1: parameter not set

â€º personaliser l'erreur

  mcp () print greetings, $1
  mcp () print greetings, ${1}
  mcp () print greetings, ${1?the one to salute}
  mcp

  â‡’ mcp:2: 1: the one to salute

â€º expansions conditionelles

  # si unset
  mcp () print greetings${1+, }${1-}
  mcp ''     # â‡’ greetings, 
  mcp        # â‡’ greetings
  mcp flynn  # â‡’ greetings, flynn

  # si unset ou vide
  mcp () print greetings${1:+, }${1:-}
  mcp ''     # greetings
  mcp        # greetings
  mcp flynn  # greetings, flynn

â€º valeur par defaut

  mcp () print greetings, ${1:-program}
  mcp () print greetings, ${1:-${you:-program}}

  mcp
    # â‡’ greetings, program
  mcp flynn
    # â‡’ greetings, flynn
  you=clu mcp
    # â‡’ greetings, clu

â€º export

  you=clu
  mcp
    # â‡’ greetings, clu
  sh -uc 'echo $you'
    # â‡’ sh: 1: you: parameter not set
  export you
  sh -uc 'echo $you'
    # â‡’ clu

â€º quick scope

  you=clu mcp
    # â‡’ greetings, clu
  print ${you-no one}
    # â‡’ no one

  you=clu
  mcp
    # â‡’ greetings, clu
  print ${you-no one}
    # â‡’ clu

â€º for you

  mcp () print greetings, ${1:-${you:-program}}
  for you ( clu tron excel ) mcp
  # â‡’ greetings, clu
  # â‡’ greetings, tron
  # â‡’ greetings, excel

â€º all of you

  mcp () print greetings, ${1:-${you:-program}}
  for you (
    clu '' tron
    excel # really ?
    awk sed vi
  ) mcp

  # â‡’ greetings, clu
  # â‡’ greetings, program
  # â‡’ greetings, tron
  # â‡’ greetings, excel
  # â‡’ greetings, awk
  # â‡’ greetings, sed
  # â‡’ greetings, vi

â€º trouver l'erreur

  mcp () print greetings, ${1:-${you:-program}}
  all=(
    clu '' tron
    excel # really ?
    awk sed vi
  )
  for you ($all) mcp

  # â‡’ greetings, clu
  # â‡’ greetings, tron
  # â‡’ greetings, excel
  # â‡’ greetings, awk
  # â‡’ greetings, sed
  # â‡’ greetings, vi

â€º ghost in the shell

  all=( clu '' tron )

  print -l $all
  # â‡’ clu
  # â‡’ tron

  print -l "$all"
  # â†’ clu | tron
  # â‡’ clu  tron

â€º modifiers

  ${(modifiers)nom}

â€º uppercase

  print -l -- ${(U)USER}
  â‡’ MC

â€º split

  print -l -- ${(s,:,)"$(getent passwd $USER )"}
  â‡’ mc
  â‡’ x
  â‡’ 1000
  â‡’ 1000
  â‡’ Marc Chantreux,,,
  â‡’ /home/mc
  â‡’ /bin/zsh

â€º quote

  quote="upercase c'est mal !!!"
  parrot="il a dit ${(qqq)quote/mal/bien}"
  print -l ${(U)parrot}
  â‡’ IL A DIT "UPPERCASE C'EST BIEN !!!"

â€º contexte de liste

  all=( clu '' tron )

    $all        â‡’ clu tron
    "$all"      â‡’ "clu  tron"
    "${(@)all}" â‡’ "clu" ""  "tron"

  print -l "${(@)all}"
  # â‡’ clu
  # â‡’
  # â‡’ tron

â€º argv

  all=( clu '' tron )
  print $#all

  argv=( "${(@)all}" )
  set -- "${(@)all}"
  print $#

  set --  a b
  local -i i
  i=1 ; for it ("$@") print $[i++] $it
  i=1 ; for it {print $[i++] $it}


